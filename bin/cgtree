#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# See the COPYING file for license information.
#
# Copyright (c) 2011 peo3 <peo314159265@gmail.com>

from __future__ import with_statement
import sys
import os, os.path
import optparse

from cgutils import cgroup
from cgutils import host
from cgutils import formatter
from cgutils.version import VERSION

def readfile(filepath):
    with open(filepath) as f:
        return f.read()

INDENT_SIZE=4
INDENT=' '*INDENT_SIZE

def get_fullname(pid):
    cmdline = readfile('/proc/%d/cmdline'%(pid,))
    if '\0' in cmdline:
        args = cmdline.split('\0')
    else:
        args = cmdline.split(' ')
    name = os.path.basename(args[0]).rstrip(':')
    if name in ['python', 'ruby', 'perl'] and len(args) >= 2:
        name = os.path.basename(args[1])
    return name

def parse_proc_stat(pid):
    items = readfile('/proc/%d/stat'%(pid,)).split(' ')
    #pid = int(items[0])
    name = items[1].lstrip('(').rstrip(')')
    ppid = int(items[3])
    pgid = int(items[4])
    sid  = int(items[5])
    if pgid != 0:
        name = get_fullname(pid)
    return (pid, name, ppid, pgid, sid)

def build_indent(n):
    if n == 0:
        return ''
    s = ''
    s += (' '*(INDENT_SIZE-1)+'|')*((n-1)/INDENT_SIZE)
    s += ' '*(INDENT_SIZE-1)+'+'
    return s

def print_process_tree(indent, pids, options):
    """
    tops = [1,2,3]
    rels = {1: [4,5], 2: [6,7], 3: [], 4: []}
    """
    procs = []
    ppids = []
    rels = {}
    for pid in pids:
        proc = parse_proc_stat(pid)
        procs.append(proc)
        ppids.append(proc[2])
        if proc[2] not in rels:
            rels[proc[2]] = []
        rels[proc[2]].append(proc)
    ppids = set(ppids)
    tops = [proc for proc in procs
            #if proc[0] in ppids and proc[2] not in pids]
            if proc[2] not in pids]
    if len(tops) == 0:
        tops = procs

    def print_proc(proc, indent):
        s = build_indent(indent)
        if proc[3] == 0:
            s += '['+proc[1]+']'
        else:
            if options.color:
                colored = False
                if proc[0] == proc[3]:
                    colored = True
                    s += '\033[95m'
                if proc[0] == proc[4]:
                    s += '\033[4m'
                    colored = True
                s += proc[1]
                if colored:
                    s += '\033[0m'
            else:
                s += proc[1]
        if options.show_pid:
            s += "(%d)"%(proc[0],)
            #s += "(%d)%s"%(proc[0],str(proc))
        print(s)

    def print_recursively(proc_list, indent):
        for proc in proc_list:
            print_proc(proc, indent)
            if proc[0] in rels:
                print_recursively(rels[proc[0]], indent+INDENT_SIZE)

    print_recursively(tops, indent)

def print_cgroup(subsys_name, cg, options):
    cg.update_pids()
    if options.debug:
        print(cg.pids)
    if options.hide_empty and len(cg.pids) == 0:
        return
    indent = build_indent(INDENT_SIZE*cg.depth)
    if options.color:
        print("%s\033[1m\033[31m%s\033[0m"%(indent, cg.name))
    else:
        print("%s%s"%(indent, cg.name))
    print_process_tree(INDENT_SIZE*cg.depth+INDENT_SIZE, cg.pids,
                       options)

def main():
    DEFAULT_SUBSYSTEM = 'cpu'

    parser = optparse.OptionParser(version='cgshowconfigs '+VERSION)
    parser.add_option('-o', action='store', type='string',
                      dest='target_subsystem', default=DEFAULT_SUBSYSTEM,
                      help='Specify a subsystem [cpu]')
    parser.add_option('-e', '--hide-empty', action='store_true',
                      dest='hide_empty', default=False,
                      help='Hide empty groups [False]')
    parser.add_option('--color', action='store_true',
                      dest='color', default=False,
                      help='Coloring [False]')
    parser.add_option('--debug', action='store_true', dest='debug',
                      default=False, help='Show debug messages [False]')
    parser.add_option('-p', '--show-pid', action='store_true',
                      dest='show_pid', default=False,
                      help='Show PID (use with -v) [False]')
    (options, _args) = parser.parse_args()
    if options.debug:
        print options

    target = options.target_subsystem
    subsys_status = cgroup.SubsystemStatus()

    if target not in subsys_status.get_all():
        print >>sys.stderr, 'No such subsystem: %s'%(target,)
        sys.exit(1)

    if target not in subsys_status.get_available():
        print >>sys.stderr, 'Disabled in the kernel: %s'%(target,)
        sys.exit(3)

    if target not in subsys_status.get_enabled():
        print >>sys.stderr, 'Not enabled in the system: %s'%(target,)
        sys.exit(3)

    mount_point = subsys_status.get_path(target)

    root_cgroup = cgroup.scan_directory_recursively(target, mount_point)

    def print_cgroups_recursively(cg):
        if options.debug:
            print(cg)

        print_cgroup(target, cg, options)
        for child in cg.childs:
            print_cgroups_recursively(child)

    print_cgroups_recursively(root_cgroup)

if __name__ == "__main__":
    main()
