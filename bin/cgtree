#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# See the COPYING file for license information.
#
# Copyright (c) 2011 peo3 <peo314159265@gmail.com>

from __future__ import with_statement
import sys
import os, os.path
import optparse

from cgutils import cgroup
from cgutils import host
from cgutils import formatter
from cgutils.version import VERSION

def readfile(filepath):
    with open(filepath) as f:
        return f.read()

INDENT_SIZE=4

def build_indent(indents):
    if len(indents) == 0:
        return ''
    s = ''
    for n in range(len(indents)):
        indent = indents[n]
        if indent == 'cont' and n == len(indents)-1:
            s += ' '*(INDENT_SIZE-1)+'+'
        elif indent == 'cont':
            s += ' '*(INDENT_SIZE-1)+'|'
        elif indent == 'last' and n == len(indents)-1:
            s += ' '*(INDENT_SIZE-1)+'`'
        else:
            s += ' '*INDENT_SIZE
    return s

class Process(object):
    def __init__(self, pid):
        self.pid = pid

        items = readfile('/proc/%d/stat'%(pid,)).split(' ')
        self.name = items[1].lstrip('(').rstrip(')')
        self.ppid = int(items[3])
        self.pgid = int(items[4])
        self.sid  = int(items[5])
        if not self.is_kthread():
            self.name = self._get_fullname()

    def _get_fullname(self):
        cmdline = readfile('/proc/%d/cmdline'%(self.pid,))
        if '\0' in cmdline:
            args = cmdline.split('\0')
        else:
            args = cmdline.split(' ')
        name = os.path.basename(args[0]).rstrip(':')
        if name in ['python', 'ruby', 'perl'] and len(args) >= 2:
            name = os.path.basename(args[1])
        return name

    def is_kthread(self):
        return self.pgid == 0 and self.sid == 0

    def is_group_leader(self):
        return self.pid == self.pgid

    def is_session_leader(self):
        return self.pid == self.sid

DECORATER = {
    'red':       lambda s: '\033[31m'+s+'\033[0m',
    'bold':      lambda s: '\033[1m'+s+'\033[0m',
    'lightblue': lambda s: '\033[95m'+s+'\033[0m',
    'underline': lambda s: '\033[4m'+s+'\033[0m',
    'kthread':       lambda s: '['+s+']',
    'cgroup':        lambda s: DECORATER['bold'](DECORATER['red'](s)),
    'groupleader':   lambda s: DECORATER['lightblue'](s),
    'sessionleader': lambda s: DECORATER['underline'](s),
}
def decorate(string, type):
    return DECORATER[type](string)

def print_process(proc, indents, options):
    s = build_indent(indents)
    if proc.is_kthread():
        s += decorate(proc.name, 'kthread')
    else:
        name = proc.name
        if options.color:
            if proc.is_group_leader():
                name = decorate(name, 'groupleader')
            if proc.is_session_leader():
                name = decorate(name, 'sessionleader')
        s += name
    if options.show_pid:
        s += "(%d)"%(proc.pid,)
    if options.debug:
        s += str(indents)
    print(s)

def print_process_tree(indents, pids, options):
    """
    tops = [1,2,3]
    rels = {1: [4,5], 2: [6,7], 3: [], 4: []}
    """
    procs = []
    ppids = []
    rels = {}
    for pid in pids:
        proc = Process(pid)
        if options.hide_kthread and proc.is_kthread():
            continue
        procs.append(proc)
        ppids.append(proc.ppid)
        if proc.ppid not in rels:
            rels[proc.ppid] = []
        rels[proc.ppid].append(proc)
    ppids = set(ppids)
    tops = [proc for proc in procs if proc.ppid not in pids]
    if len(tops) == 0:
        tops = procs

    def print_recursively(proc_list, _indents):
        for proc in proc_list:
            if proc.pid == proc_list[-1].pid:
                __indents = _indents+['last']
            else:
                __indents = _indents+['cont']

            print_process(proc, __indents, options)

            if proc.pid in rels:
                print_recursively(rels[proc.pid], __indents)

    print_recursively(tops, indents)

def print_cgroup(cg, indents, options):
    cg.update_pids()
    if options.debug:
        print(cg.pids)
    if options.hide_empty and len(cg.pids) == 0:
        return
    indent_str = build_indent(indents)
    if options.color:
        print("%s%s"%(indent_str, decorate(cg.name, 'cgroup')))
    else:
        print("%s%s"%(indent_str, cg.name))
    print_process_tree(indents, cg.pids, options)

def main():
    DEFAULT_SUBSYSTEM = 'cpu'

    parser = optparse.OptionParser(version='cgshowconfigs '+VERSION)
    parser.add_option('-o', action='store', type='string',
                      dest='target_subsystem', default=DEFAULT_SUBSYSTEM,
                      help='Specify a subsystem [cpu]')
    parser.add_option('-e', '--hide-empty', action='store_true',
                      dest='hide_empty', default=False,
                      help='Hide empty groups [False]')
    parser.add_option('-k', '--hide-kthread', action='store_true',
                      dest='hide_kthread', default=False,
                      help='Hide kernel threads [False]')
    parser.add_option('--color', action='store_true',
                      dest='color', default=False,
                      help='Coloring [False]')
    parser.add_option('--debug', action='store_true', dest='debug',
                      default=False, help='Show debug messages [False]')
    parser.add_option('-p', '--show-pid', action='store_true',
                      dest='show_pid', default=False,
                      help='Show PID (use with -v) [False]')
    (options, _args) = parser.parse_args()
    if options.debug:
        print options

    target = options.target_subsystem
    subsys_status = cgroup.SubsystemStatus()

    if target not in subsys_status.get_all():
        print >>sys.stderr, 'No such subsystem: %s'%(target,)
        sys.exit(1)

    if target not in subsys_status.get_available():
        print >>sys.stderr, 'Disabled in the kernel: %s'%(target,)
        sys.exit(3)

    if target not in subsys_status.get_enabled():
        print >>sys.stderr, 'Not enabled in the system: %s'%(target,)
        sys.exit(3)

    mount_point = subsys_status.get_path(target)

    root_cgroup = cgroup.scan_directory_recursively(target, mount_point)

    def print_cgroups_recursively(cg, indents):
        if options.debug:
            print(cg)

        print_cgroup(cg, indents, options)
        for child in cg.childs:
            if child == cg.childs[-1]:
                _indents = indents+['last']
            else:
                _indents = indents+['cont']
            print_cgroups_recursively(child, _indents)

    print_cgroups_recursively(root_cgroup, [])

if __name__ == "__main__":
    main()
